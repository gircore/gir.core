using System;
using System.Linq;
using System.Runtime.InteropServices;

{{~
$managed_name = get_metadata "ManagedName"
~}}

#nullable enable

namespace {{ namespace.name }}
{
    // AUTOGENERATED FILE - DO NOT MODIFY

    public delegate {{ return_value | write_managed_return_value }} {{ $managed_name }}({{ parameter_list | write_managed_arguments}});
    
    /// <summary>
    /// Call Handler for {{ $managed_name }}. A call annotation indicates the closure should
    /// be valid for the duration of the call. This handler does not implement any special
    /// memory management. 
    /// </summary>
    public class {{ $managed_name }}CallHandler : IDisposable
    {
        public Native.{{ symbol_name }} NativeCallback;

        private {{ $managed_name }} managedCallback;
    
        public {{ $managed_name }}CallHandler({{ $managed_name }} managed)
        {
            managedCallback = managed;
            NativeCallback = ({{ write_callback_marshaller_params parameter_list }}) =>
            {
                {{ include 'native.delegate.marshaller.sbntxt' }}
            
                {{~ if return_value | return_value_is_void != true ~}}
                return {{ write_callback_marshaller_return return_value "managedCallbackResult" }};
                {{~ end ~}}
            };
        }
        
        public void Dispose()
        {
            // This implements IDisposable just to signal to the caller that this class contains
            // disposable state. Actually there is no state which needs to be freed. But if an instance
            // of this object is freed to early the NativeCallback can not be invoked from C anymore
            // which breaks any native code relying on the availability of the NativeCallback.
        }
    }
    
    /// <summary>
    /// Async Handler for {{ $managed_name }}. An async annotation indicates the closure will
    /// be called precisely once, after which it is then available for garbage collection.
    /// </summary>
    public class {{ $managed_name }}AsyncHandler : IDisposable
    {
        public Native.{{ symbol_name }} NativeCallback;

        private {{ $managed_name }} managedCallback;
        private GCHandle gch;
    
        public {{ $managed_name }}AsyncHandler({{ $managed_name }} managed)
        {
            managedCallback = managed;
            gch = GCHandle.Alloc(this);
            NativeCallback = ({{ write_callback_marshaller_params parameter_list }}) =>
            {
                {{ include 'native.delegate.marshaller.sbntxt' }}

                // Async callbacks are only ever called once
                gch.Free();
            
                {{~ if return_value | return_value_is_void != true ~}}
                return {{ write_callback_marshaller_return return_value "managedCallbackResult" }};
                {{~ end ~}}
            };
        }
        
        public void Dispose()
        {
            if (gch.IsAllocated)
                gch.Free();
        }
    }

    /// <summary>
    /// Notified Handler for {{ $managed_name }}. A notified annotation indicates the closure should
    /// be kept alive until it is manually removed by the user. This removal is indicated by a
    /// destroy_notify event, emitted by the relevant library. Pass <c>DestroyNotify</c> in place of a
    /// destroy_notify callback parameter. 
    /// </summary>
    public class {{ $managed_name }}NotifiedHandler : IDisposable
    {
        public event EventHandler<EventArgs>? OnDestroyNotify;
        public Native.{{ symbol_name }} NativeCallback;
        public GLib.Native.DestroyNotifyCallback DestroyNotify;

        private {{ $managed_name }} managedCallback;
        private GCHandle gch;

        public {{ $managed_name }}NotifiedHandler({{ $managed_name }} managed)
        {
            DestroyNotify = DestroyCallback;
            managedCallback = managed;
            gch = GCHandle.Alloc(this);

            NativeCallback = ({{ write_callback_marshaller_params parameter_list }}) =>
            {
                {{ include 'native.delegate.marshaller.sbntxt' }}
            
                {{~ if return_value | return_value_is_void != true ~}}
                return {{ write_callback_marshaller_return return_value "managedCallbackResult" }};
                {{~ end ~}}
            };
        }

        private void DestroyCallback(IntPtr userData)
        {
            OnDestroyNotify?.Invoke(this, EventArgs.Empty);

            // Allow for garbage collection
            gch.Free();
        }
        
        public void Dispose()
        {
            if (gch.IsAllocated)
                gch.Free();
        }
    }
}
