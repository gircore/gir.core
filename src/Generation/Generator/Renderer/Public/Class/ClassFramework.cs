using System;
using System.Collections.Generic;
using System.Linq;
using Generator.Model;

namespace Generator.Renderer.Public;

internal static class ClassFramework
{
    public static string Render(GirModel.Class cls)
    {
        var @sealed = cls.Final ? "sealed " : string.Empty;
        var newKeyWord = Class.IsGObjectObject(cls) ? string.Empty : "new ";

        return $@"
using System;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace {Namespace.GetPublicName(cls.Namespace)};

// AUTOGENERATED FILE - DO NOT MODIFY

{PlatformSupportAttribute.Render(cls as GirModel.PlatformDependent)}
[GObject.Handle<{Class.GetFullyQualifiedInternalHandleName(cls)}>]
public {@sealed}partial class {cls.Name} {RenderInheritance(cls)}
{{
    protected internal {cls.Name}({Class.GetFullyQualifiedInternalHandleName(cls)} handle) : base(handle) {{ }}

    [ObsoleteAttribute(""Regular C# constructors on native classes will be removed in a future version. Please see the linked documentation for more details. It contains scenarios and possible solutions to prepare for the upcoming changes."", DiagnosticId = ""GirCore1007"", UrlFormat = ""https://gircore.github.io/docs/integration/diagnostic/1007.html"")]
    public {cls.Name}(params GObject.ConstructArgument[] constructArguments) : this(CreateLegacy(constructArguments)) {{ }}
    [ObsoleteAttribute(""This constructor is a workaround to keep legacy APIs alive. Do not use it."")]
    protected {cls.Name}(GObject.CreationData data) : base(data) {{ }}

    /// <summary>
    /// Creates a new {cls.Name} and sets the properties specified by the construct arguments.
    /// </summary>
    /// <param name=""constructArguments"">The properties to set.</param>
    public static {newKeyWord}{cls.Name} NewWithProperties(GObject.ConstructArgument[] constructArguments)
    {{
        var ptr = GObject.Internal.Object.NewWithProperties(GetGType(), constructArguments);
        return CreateInstance(ptr);
    }}

    /// <summary>
    /// Creates a new managed {cls.Name} instance for a given pointer.
    /// </summary>
    public static {newKeyWord}{cls.Name} NewFromPointer(System.IntPtr ptr, bool ownsHandle) => ({cls.Name}) GObject.Internal.InstanceWrapper.WrapHandle<{cls.Name}>(ptr, ownsHandle);

    {cls.Constructors
        .Select(ConstructorRenderer.Render)
        .Join(Environment.NewLine)}
        
    private static {cls.Name} CreateInstance(IntPtr ptr)
    {{
       var handle = new {Class.GetFullyQualifiedInternalHandleName(cls)}(ptr);
       var obj = new {cls.Name}(handle);

       GObject.Internal.InstanceCache.AddToggleRef(obj);
       {RenderUnref(cls)}

       return obj;
    }}

    private static GObject.CreationData CreateLegacy(GObject.ConstructArgument[] arguments)
    {{
        var ptr = GObject.Internal.Object.NewWithProperties(GetGType(), arguments);
        var handle = new {Class.GetFullyQualifiedInternalHandleName(cls)}(ptr);
        
        return new GObject.CreationData
        {{
            Handle = handle, 
            Setup = (obj) => 
            {{ 
                GObject.Internal.InstanceCache.AddToggleRef(obj);
                {RenderUnrefLegacy(cls)}
            }}
        }};
    }}
}}";
    }

    private static string RenderInheritance(GirModel.Class cls)
    {
        var parentClass = cls.Parent is null ? null : $"{ComplexType.GetFullyQualified(cls.Parent)}";
        var interfaces = cls.Implements.Select(ComplexType.GetFullyQualified);

        var elements = new List<string>(interfaces);

        if (parentClass is not null)
            elements.Insert(0, parentClass);

        return elements.Count == 0
            ? string.Empty
            : $": {string.Join(", ", elements)}";
    }

    private static string RenderUnref(GirModel.Class cls)
    {
        return Class.IsInitiallyUnowned(cls)
            ? """
              GObject.Internal.Object.TakeRef(ptr);
              GObject.Internal.Object.Unref(ptr);
              """
            : "GObject.Internal.Object.Unref(ptr);";
    }

    private static string RenderUnrefLegacy(GirModel.Class cls)
    {
        return Class.IsInitiallyUnowned(cls)
            ? """
              var ptr = obj.Handle.DangerousGetHandle();
              GObject.Internal.Object.TakeRef(ptr);
              GObject.Internal.Object.Unref(ptr);
              """
            : "GObject.Internal.Object.Unref(obj.Handle.DangerousGetHandle());";
    }
}
