using System;
using System.Runtime.InteropServices;

#nullable enable

{{~ $record_name = get_metadata "Name" ~}}
{{~ $safe_handle = "Native." + get_metadata "SafeHandleRefName" ~}}

namespace {{ namespace.name }}
{
    // AUTOGENERATED FILE - DO NOT MODIFY
    public partial class {{ $record_name }} : GLib.IHandle
    {
        private readonly {{ $safe_handle }} _handle;
        
        public {{ $safe_handle }} Handle => !_handle.IsInvalid ? _handle : throw new Exception("Invalid Handle");
        
        // TODO: Having these both called Handle is confusing - rename?
        IntPtr GLib.IHandle.Handle => _handle.DangerousGetHandle();
        
        // Override this to perform additional steps in the constructor
        partial void Initialize();
        
        public {{ $record_name }}(IntPtr ptr) : this(new {{$safe_handle}}(ptr)){ }
        
        public {{ $record_name }}({{ $safe_handle }} handle)
        {
            _handle = handle;
            Initialize();
        }
        
        // TODO: Default Constructor (allocate in managed memory and free on Dispose?)
        // We need to be able to create instances of records with full access to
        // fields, e.g. Gdk.Rectangle, Gtk.TreeIter, etc. 
        
        // TODO: Implement IDispose and free safe handle
    }
}